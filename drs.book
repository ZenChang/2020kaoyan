分布式实时处理系统,原理架构与实现

前言:
云计算 && 大数据 -->海量数据处理和数据挖掘
MapReduce && Bulk Synchronous Parallel

客户要求:服务 价值 数据 便利 -->实时响应

MapReduce是数据批处理 --> 实时处理稍显乏力

数据批处理和数据实时处理的需求有着本质的区别

实时性:及时推送数据 && 数据划分单位
HDFS:存储推送数据-->无法满足实时性要求
Apache Spark提升批处理性能,但是运行机制本身导致不能从根本上解决实时性问题

数据规模的爆炸增长-->数据实时处理的需求-->专注于实时性,规模化的计算平台-->Apache Storm

Storm:可靠的,高容错性的,实时分布式处理平台

本书的目的就是解开面纱,让更多的人少走弯路:Hurricane

高性能的实时处理系统-->高性能的网络层-->支持大量的并发-->跨平台的网络库Meshy,作为Hurricane的传输层

c++11:auto override thread chrono funcational 统一初始化 lambda

分布式计算存储概念-->网络通信基础知识-->网络高层抽象知识
-->C++相关知识-->Hurricane的设计方案-->Hurricane主体功能实现
-->Meshy跨平台网络框架及应用

Hurricane实时处理系统:c++11编写的,高性能为关注点的分布式实时计算框架,
使用流模型作为计算模型,同时提供易于理解的高层接口

第一章:分布式计算概述
分布式概念+分布式系统特性+分布式存储类型+产品实例+对比批处理方案&&Storm流计算模型-->实时处理系统

1.1 分布式概念
互联网没有集中式的控制中心,大量分离且互联的节点组成-->类比到分布式概念上

集中式系统:使用计算能力强大的服务器处理大量的计算任务,其他很多终端作为数据I/O
分布式系统:将海量计算能力的大问题拆解为许多小块,将小块分配给系统中不同的计算节点进行处理,
最后将分开的计算结果合并为最终结果

手段:在不同节点之间进行数据通信和协调,一般指网络消息

一套分布式系统会使用网络上的硬件资源和软件组件进行计算,而各个节点之间通过一定的方式通信

1.2 分布式计算及其原理
分布式计算:将计算任务分摊到大量计算节点上,一起完成海量的计算任务
分布式计算:将一个复杂庞大的计算任务划分为一个个的小任务,分摊到不同的计算节点上,
让其并行执行,而每个计算节点也可以并行处理自身的任务,更加充分利用CPU资源,
最后将每个节点的结果汇总,得到最后的计算结果

步骤:
1. 设计分布式计算模型:各个组件如何运行,如何消息通信,如何管理
2. 任务分配:能否分配,如何分配
3. 编写并执行分布式程序:使用特定的分布式框架和计算模型,将分布式算法转为实现,并保证整个集群的高效运行

1. 计算任务的划分:并行计算互不相干,但分布式节点之间产生数据依赖,任务划分就要合理有效
2. 节点之间高效通信:消息队列:将节点之间的数据依赖变为节点之间的消息传递,
分布式存储系统:将节点的执行结果暂存在数据库中,其他节点等待从数据库中获取数据,

1.3 分布式系统特性
分布式系统中的某台电脑停止运行了,但你的软件却永远不会

特性:容错性,高可扩展性,开放性,并发处理能力和透明性

1.3.1 容错性
应对问题:某个节点发生故障
检测,恢复,和避免整套系统的不可用

检测故障:校验消息和数据有无以及合法性, 网络延迟,消息乱序
故障恢复:回滚正确数据的状态,确保不传递错误数据,事务性
故障避免:消息重发,冗余
一定时间范围内消息不可达时进行重传,多次尝试后仍不可达认为,节点出现问题
数据冗余存储一定程度上可以降低数据出错的概率
冗余的节点,冗余的路由器,冗余的数据库数据

1.3.2 高可扩展性
系统运行过程中自由地对系统内部节点或现有功能进行扩充,而不影响现有服务的运行
1. 更新需要停机
2. 没有开放接口,需要中间层作转换

Storm通过json格式:1. 解决了接口难以扩展和集成的问题 2. 后续节点扩充的问题

1.3.3 开放性
自我扩展和其他系统集成
OpenAPI 最好是遵循某种协议

1.3.4 并发处理能力
并发导致的一致性问题:同步问题
可用性问题:缓冲或加锁会导致可用性

分布式系统CAP特性:
Consistency: 统一数据在集群中的所有节点,在同一时刻是否都是同样的值
Availability: 集群中一部分节点故障后,集群整体是否还能处理客户端的更新请求
Partion Tolerance:是否允许数据的分区,分区是指允许集群中的节点之间无法通信

1.3.5 透明性
将分布式系统当成一个整体给用户看待

1.4 通用分布式计算系统

1.4.1 Apache Hadoop

Hadoop:Apache基金会开发的分布式存储与计算框架,
用户不需要了解分布式计算原理,就可以轻松开发出分布式计算程序,
可以充分利用集群中的闲置的计算资源,将集群的真正威力调用起来.

HDFS:Hadoop分布式文件系统:将文件数据分布式地存储在集群中的不同节点上
MapReduce:针对大量数据的分布式计算系统 : YARN:任务调度和资源管理的框架

1. 历史:Hadoop MapReduce--> Google MapReduce
Hadoop HDFS-->Google GFS

Hadoop:目前世界上最流行的分布式计算框架
Apache: HBase,Cassandra,Avro,Hive,Mahout

2. HDFS
HDFS:主从式的分布式文件系统,是GFS的一种开源实现
HDFS:利用大量廉价存储器组成分布式存储集群,取代昂贵的集中式磁盘存储阵列
HDFS集群:一个NameNode,多个DataNode, Secondary NameNode

1. NameNode:整个集群的管理者,并不存储数据本身,而是存储文件系统的元数据:命名空间,外部客户端的访问
决定将文件内容映射到DataNode数据块上,Secondary NameNode
2. Secondary NameNode:
NameNode会将数据实时备份到Secondary NameNode上
3. DataNode:
实际的数据存储节点
响应NameNode的命令(创建,删除,复制)
NameNode会读取DataNode的心跳,判断DataNode是否活着
同一份数据会存储在多个DataNode上,一旦一个DataNode宕机,NameNode会采取相应策略
4. MapReduce
小块数据-->Map中-->Reduce
Resource_Manager:管理整个集群
Node_Manager:管理某个节点的容器并监视其资源使用
MRAppMaster

3. Apache Hadoop特性
1. 高可靠性:可靠地将数据存储在节点上
2. 高可扩展性:存储和计算节点可以快速扩展,并自动进行负载均衡
3. 高效性:各个节点之间动态调动数据,保证每个节点存储均衡,从不同节点并行读取,提高读取速度
4. 高容错性:将数据冗余存储在不同节点上,保证数据容错性,计算任务失败时也会自动重新分配任务
5. 低成本:开源不用花钱,廉价节点取代超级计算机
缺陷:实时性较差,积累一批数据,然后手动或定时启动MapReduce处理完这批数据,
下一批数据积累一定程度,在进行新一轮任务,而不是随着数据的到来及时处理

为了提高实时性,我们需要增加缓存优化,但是MapReduce的各个任务之间的通信
采用HDFS机制,因此没有实时性

1.4.2 Apache Spark
解决Apache Hadoop计算速度慢的问题
1. 执行速度极快
将中间结果放在内存中而不是HDFS中,提升100倍
2. 支持多种运行模式
除了可以独立在集群上执行任务以外,可以执行在E2C,YARN上,也可以从HDFS,HBase,Hive,Cassandra中读取数据
3. 多种计算模型
SQL接口,Spark流模型,Mlib机器学习接口,GraphX图形计算接口

致命问题:计算模型仍然是任务式的
对于实时流入又要实时反馈的数据,Spark亦无法满足

1.4.3 Apache Storm
海量数据任务的批处理系统在实时计算处理方面越发显得乏力
任务式计算模型和实时处理系统有着本质的区别

实时处理系统要求:及时推送数据并且将数据分成尽可能小的单位
Apache Storm:实时计算,数据处理保序
1. 高可扩展性:增加机器并提高计算拓扑的并行程度,10个节点的Apache Storm集群可以每秒100w消息
2. 高容错性:消息异常,重新发送相关元组
3. 易于管理:使用ZooKeeper来协调集群内的节点配置,并扩展集群规模
4. 消息可靠性:确保所有到达计算拓扑的消息都能被处理

1.5 分布式存储系统
分布式存储技术和分布式计算技术
高性能,高可扩展性,高可用性,以及低成本的分布式存储系统

1.5.1 分布式存储概念

分布式存储系统:一个计算机网络,该网络上的多个节点都可以存储信息,
节点之间可以复制和同步

一般是非关系型数据库
最重要的问题:如何在多节点中保持数据的一致性,容错性,数据可恢复能力和负载均衡

数据均匀 && 数据频率
Cassandra
事务性
NoSQL:
1. 模式相对自由,适合存储非结构化数据
2. 数据一致性和事务性较弱
3. 查询和关联的功能有限
4. 读写性能问题,写入很快,读取较慢

1.5.2 分布式存储系统的特点:低成本,高度可定制

1. 高性能
2. 高可扩展性
3. 高可用性
4. 低成本

1.5.3 分布式存储系统分类
1. 列存储系统:HBase,Cassandra
2. 文档型存储系统:MongoDB,CouchDB
3. 图形存储系统:Neo4j:以节点为单位,在节点之间建立网络来建立数据之间的关系
数据以网络形式存储,可以建立遍历算法,推荐系统
4. 键值对存储系统:Redis,Riak,
5. 分布式文件系统
不属于数据库

1.5.4 常见的分布式存储系统
1. HBase
2. Cassandra
3. MongoDB

第二章:分布式系统实时系统
2.1 时代的浪潮
2.1.1 集中式通信网
2.1.2 去中心化

2.2 可靠的数据链路
2.2.1 数据分组
2.2.2 帧同步
2.2.3 差错控制
2.2.4 链路管理
2.2.5 问题与解决方案

2.3 分层架构
物理层-->网线
数据链路层-->分组+分时复用+逻辑链路-->ARP + RARP
网络层-->路由和转发-->IP + ICMP
传输层-->字节流端到端-->TCP + UDP
应用层-->字节流解释为人类可读的报文-->DNS + HTTP + PING + OSP

Request For Comments(RFC)

TCP/IP协议:
1.物理层:在我们的协议之外
2.数据链路层:保证相邻节点之间数据可靠传递
3.网络层:保证任意两节点间的数据包的传送
4.传输层:端到端的字节流抽象
5.构建应用程序协议

2.4 网络层
2.4.1 寻找路径
链路状态法 + 距离向量法

LS算法:1.确认所有节点的编号2.测量到每个机器节点的距离3.共享信息,构建拓扑4.DijkstraO(n^2)
DV算法:1.建立路由表2.计算相邻节点的权值3.定时发送路由表到相邻节点
4.哪个相邻节点与目标节点的权值最小,转发给哪个.
路由表是可以收敛的

2.4.2 网络分层
将机器节点进行分组
2.4.3 TCP/IP概述
传输的顺序,数据的格式和内容有一个约定和规则:数据通信和传输协议
TCP/IP协议族:整个协议体系框架中包含不同层次,不同用途的协议

自下而上的四层协议组成:数据链路层,网络层,传输层,应用层
高层次的协议调用低层次的接口和服务,不需要了解低层次协议的算法和协议

2.4.4 IP协议

IP协议是网络层协议的最主要的协议
IP数据包中包含了目的地的地址,用来数据转发
如果无法直接发送就只能通过路由器中转,
IP协议会根据目的地址决定向哪一个后继路由器或节点进行转发,直到发送到目的端为止

特殊情况:中途断电,
Internet Control Message Protocol
ICMP:网络控制报文协议:探测网络连接
将简单的出错报告信息发回到发送端,由发送端处理
注意:ICMP只负责报告,不负责处理

ICMP原理: 机器A-->ICMP报文-->路由器-->ICMP报告错误-->机器A

1.IP协议详解

2. 路由与转发规则
IP报文进入路由器-->有匹配路由-->查找路由表地址-->在直接链路上-->转发
IP报文进入路由器-->没有匹配路由-->丢弃
IP报文进入路由器-->有匹配路由-->不在直接链路上-->以下一跳作为目的地址-->查找路由表

路由与转发规则需要进一步确认:https://blog.csdn.net/u010563967/article/details/25810641

2.5 传输层
传输层只关注数据发送的起始端和目的端,提供端到端的数据通信
数据分包,端到端传输,数据可靠性传输

2.5.1 数据自动分包
首先将应用层的数据的字节流缓存下来-->取适当大小的字节流封装成网络层的数据包-->网络层发送
2.5.2 端到端的传输
每个应用程序绑定一个PID
网络层选择IP匹配到目标机器节点,然后根据PID将消息分配到不同应用程序上
2.5.3 数据的可靠性传输
与数据链路层的重传机制不同的是:数据包可能会乱序到达,需要有一个表示顺序的编号.
1.TCP协议(transmission control protocol)
面向连接的可靠的基于字节流的传输层通信协议
自带超时重传和确认机制
3次握手和4次分手
2.UDP协议(user datagram protocol)
发送方是怎样知道传输出错的呢
多媒体信息或频率比较高的信息
RTP(real_time transport protocol)
SIP(session initial protocol):invite消息在一定时间内没有得到response消息,重新发送
Cisco RUDP协议
方法:利用应用层进行UDP数据传输的可靠性,同时享受UDP数据传输的高效率
UDP虽然有校验和,但是没有用起来,

3. 传输层协议小结

2.6 应用层
其实就是应用程序的一个高层协议

应用层:终端用户的认证,数据处理与压缩,记录数据流来源的应用程序
协议最多,类型最杂
ping,telnet,OSPF,DNS,HTTP

2.6.1 ping
Packet Internet Groper 用于测试网络连接
ping-->ICMP-->目的-->回复ICMP-->源
虽然ICMP属于网络层协议,但是ping是应用层程序,因此还是应用层协议

2.6.2 telnet
telnet所有数据都是明文传送,因此被ssh取代.telnet服务也往往被禁用,防止安全问题

2.6.3 OSPF
OSPF:(开放最短路径优先, Open Shortest Path First)
LS路由协议的一种实现,使用了Dijkstra算法,单一自治系统内决策路由
特点:
1. 快速适应网络变化
2. 在网络发生变化时,发送触发更新
3. 以较低的频率发送定期更新,称为链路状态刷新
4. 支持不连续子网和CIDR卡
5. 支持手动路由汇总
6. 收敛时间短
7. 采用Cost作为度量值
8. 使用区域概念,减少协议对路由器的cpu和内存的占用
9. 有路由验证功能,支持等价负载均衡

2.6.4 DNS
DNS(域名系统:Domain Name System)
域名和IP之间的映射
DNS运行在UDP之上

2.6.5 HTTP协议
HTTP(超文本协议 Hype Text Transfer Protocol)

HTTP使用URI(unified resource identified)作为网络资源的唯一标识

绝对URI和相对URI

http://demo.com/article/1211/?scroll=true
http:// 协议名称
demo.com 域名
/article/1211 资源路径
scroll=true 查询路径

有协议名称和域名,称为绝对路径,否则称为相对路径

请求消息和响应消息
通用头域包括:Cache-Control, Connection, KeepAlive, Data, Program

2.7 基于消息协议的公告牌
需要应用程序使用网络

2.7.1 需求描述
张贴消息,一个节点在公告牌上张贴消息,其他节点去实时获取任何节点的新消息
当然每次只能获取最新消息
如果服务器没有任何消息,客户端则等待一段时间

客户端:连接的发起方
服务器:监听客户端,并接受连接

每个节点都会有一个服务器和客户端
服务器一旦接受客户端的请求,就会与客户端握手,建立连接,根据客户端的请求将最新的消息发送给客户端
当客户端读取完服务器的消息后,立即断开连接

抽象为两个阶段:1.客户端的请求 2.服务器的响应
简单描述:客户端发送一个请求到服务器,服务器根据请求发送一个响应到客户端,最后结束这一次请求

2.7.2 制定协议
传输层提供的就是端到端的字节流抽象

1. 请求
超时时间
2. 响应
响应状态代码
响应数据类型
响应数据长度
响应内容
完成的任务:去特定的服务器上去获取响应的消息,若消息一直不更新,那么
客户端也只能一直看到一条相同的信息

2.8 分布式通信举例-MapReduce
基本思想:将计算量非常大的计算拆分为很多部分,每一个节点只负责计算一个部分
最后再将所有节点的结果通过一定的方式汇总到一起,得出最后结果


    -->map
task      -->reduce
    -->map

通信:HDFS
Map节点和Reduce节点的通信并不是使用收发消息的方式,而是去操作一个双方共享的分布式文件系统

Map从HDFS中读取数据,并将计算结果写入到HDFS中,
再由Reduce节点从HDFS中读取Map的中间结果,并将最终合并结果写入到HDFS中

HDFS:将请求发送给NameNode,NameNode存储整个文件系统的元数据
可以得知哪个文件存放在哪个节点
然后NameNode找到合适的DataNode,由DataNode服务程序接管请求
与客户端进行真正的数据通信
最后读写请求完成后,NameNode会更新元数据,并对存储的数据重新进行负载均衡
也就是建立数据的多份副本,分发给不同的节点,做到冗余存储

这样我们就可以将数据存储在分布式集群中并进行读写
而Map节点和Reduce节点正是通过读取HDFS的文件实现通信

Map节点将计算结果以一定的命名方式写到HDFS中,然后Hadoop会激活Reduce节点
让Reduce节点去对应的位置寻找对应的计算结果,然后再将合并结果以一定的命名方式写入HDFS

2.9 本章小结

第三章 通信系统高层抽象
直接使用Socket的弊端:设计协议,编解码,开发服务器,一般不采用

解决复杂问题的方法:分层
介绍网络通信的高层抽象


3.1 RPC介绍
本地应用程序:庞大系统分为子系统,子系统分为更小的模块,再细分模块为函数
A模块调用B模块的公有函数

分布式系统两个系统在不同的服务器上
子系统A想要调用子系统B,无法通过过程调用来实现,而是要通过网络通信
子系统A的服务器向子系统B的服务器发送网络请求,子系统B接受请求并调用服务
再将调用结果返回给子系统A服务器

当模块之间的调用变为大量的网络请求之后,整个代码的可读性和可维护性势必会收到不利影响

为了模拟对程序员来说最简单直观的过程调用,RPC应运而生(Remote Procedure Call)

远程过程调用:开发者不需要了解底层网络技术的情况下,可以像调用本地方法一样,
调用远程服务器提供的函数

作为一个合格的程序员,虽然我们不必要自己构造我们的工具,
但是我们必须知道工具是如何构造出来的(不造车轮但必须知道车轮原理)

1. 调用方调用远程过程的代码
2. RPC对过程的封装
3. RPC编码
4. RPC连接客户端
5. RPC连接服务器
6. RPC解码
7. 传递给服务器成员函数
8. 执行函数
1. 将调用结果进行封装
2. RPC编码
3. RPC解码
4. 传递给客户端的成员函数

RPC调用方式:同步调用和异步调用

同步调用:客户端必须要等到服务器执行任务返回后才能继续执行
异步调用(常用):客户端执行之后继续执行其他代码,通过回调函数对服务器的响应进行处理
例如:Thrift

3.2 RESTful
表现层状态转移
REST(Representational State Transfer)是一种架构设计风格
结构清晰,符合标准,易于理解

目的:在符合架构原理的前提下,理解和评估以网络为基础的应用软件的架构设计
得到一个功能强,性能好,适宜通信的架构

并不一定要采用http协议

3.2.1 资源和表现层
资源概念:网络上的某一个实体,类比于一切皆对象<==>一切皆资源,文字声音视频甚至服务等
每个资源都有一个唯一标识符:Uniform Resource identified

所有对网络的访问都可以抽象为对资源的访问

表现层:资源的一种表现方式,文本,xml,json等
严格来说:URI不需要包含格式
如果使用http协议,格式需要包含在accept和content-type中,
但是对于静态资源访问性能的妥协,我们一般会将静态资源后缀名写到URI中,
以直接访问对应的静态资源

3.2.2 状态转移
"资源的修改"抽象成"资源的状态转移"

REST使用的基本技术是无状态的,因此所有状态都要保存在服务器,
核心:完成资源的状态转移,基于资源的表现层,(无论是用户传递的数据,还是服务器反馈的数据)
称为"表现层状态转移"

HTTP:
GET:获取资源的当前某种表现层,GET不能产生资源的表现层状态转移
POST:传递数据,创建资源.允许请求携带请求体,在请求体中插入资源的表现层.
PUT:更新资源.改变已存在资源的状态.
DELETE:删除资源.将资源的状态转变为不在

3.2.3 RESTful总结
1) RESTful 使用URI表示每个资源
2) RESTful风格使用特定方式操作服务器资源,完成服务器资源的状态转移
3) 客户端和服务器之间通信的数据,表示资源的某种表现层
4) 区分RESTful风格设计

3.3 消息队列
RPC和RESTful的比较:
1. 调用(RPC直接调用过程,RESTful调用URI)
2. 客户端向服务器传递数据
3. 服务器向客户端返回数据
调用方和被调用方是直接耦合的关系
"松耦合":消息队列, 也是一种通信抽象

消息队列是一种消息投递的抽象
抽象:模块之间互相调用分解为互相投递消息,而模块可以是一个进程中的两个线程
可以是一台机器上的两个进程,可以是两台机器上的服务,
甚至可以是一个集群到另一个集群.

哪怕是linux这种宏内核操作系统中,消息队列也是进程通信(IPC)的主要方式,
而这种天生的隔离性,也使得这种抽象可以应用于不同领域

发送者-->消息队列-->接收者

发送方并不是直接将消息发送到接收方,而是通过一个名为消息队列的服务,
由消息队列帮助发送方完成消息的投递
而接收者则主动去消息队列去取消息,当获取到消息之后,执行相应服务,
并通过消息队列向发送方投递一个回执,表示服务执行结果

分布式消息队列:
消息队列也可以成为一种实现RPC的技术,

消息队列应用到网络通信中时,需要一台独立的消息队列服务器,或者是消息队列服务器集群
专门负责处理消息的转发.
模块化与分离式的设计,让消息队列专注于消息的快速投送,而让其他服务专注于业务功能

消息队列:
MessageQueue-->Message

MessageQueue.registerService(serviceName):用于注册服务
MessageQueue.send(message):用于发送消息,同步发送服务

Message.setType():设置消息类型
Message.setParam():设置消息参数
Message.setDestination:设置消息的发送目的地

3.4 序列化
在高层抽象中,我们把这种编码和解码称为"序列化"和"反序列化"

序列化就是将语言运行时数据转化为可以传输的二进制数据,
反序列化就是将二进制数据转化为语言运行时数据

C#,java等语言自带序列化和反序列化,但是不能跨语言

跨语言跨平台的序列化解决方案:
第一类是专注于对象的内部数据序列化和反序列化,xml,json
第二类是构建一个完整的跨平台的RPC服务体系,不仅是数据,连功能接口都是语言无关的

第一类如xml,json等可以将对象序列化为xml,然后另一种语言可以反序列化回来
优点:
1. 所有数据都使用文本传输,序列化后的内容人类可以理解,方便检查错误
2. 得到所有语言的广泛支持
缺点:
1. 不同语言接口繁多,学习成本较高
2. 纯文本传输数据冗余严重
也可以采用自定协议的方案,普遍采用二进制,protocol_buffer,Apache Avro
采用二进制协议,优点:数据冗余少,体积小,性能好；接口一致,
缺点:二进制自身很难理解,出现问题很难发现,支持语言种类较少,自己开发进行解析成本更高

第二种方案:不仅提供了序列化能力,而且提供了跨平台的统一接口,比如Thrift

3.5 使用Thrift实现公告牌服务
问题：底层通信的处理占用了大量的代码，数据的序列化．
Thrift提供了稳定健壮的RPC服务器实现,并且提供了序列化和饭序列化

3.5.1 Apache Thrift
facebook
Thrift关键:IDL(接口定义语言)

3.5.2 安装Apache Thrift
以来boost

3.5.3 编写Thrift接口
3.5.4 实现服务器
3.5.5 实现客户端

3.6 本章小结
通信系统的高层抽象
RPC, RESTful,消息队列和序列化


第四章 走进c++高性能编程
静态语言:运行时无法动态创建或修改类c++
动态语言:可以在运行时动态增删改查对象和函数
原理在将类,函数等元数据保存在二进制中

4.1 基于c++的留言板系统

4.1.1 基于socket的通信
4.1.2 C++的内存与资源管理

4.2 来自服务器的天书
4.2.1 编码
4.2.2 c++98的编码缺陷
宽字符只规定了字节大于等于2,却没有规定具体等于几
4.2.3 c++11编码支持
char-->string-->uft-8
char16_t-->u16string-->utf16
char32_t-->u32string-->utf32
std::string u8_str = u8"编码测试";
std::u16string u16_str = u16"编码测试";
std::u32string u32_str = u32"编码测试";

std::codecvt_utf8, std::codecvt_utf16, std::codecvt_utf8_utf16

任意编码之间的转换
libiconv库的iconv

4.3 繁忙的服务器

4.3.1 分身乏术
因输入输出引起的程序暂停称为阻塞

4.3.2 fork 分身术

4.3.3 进程间通信
命名管道

4.3.4 轻量级分身

4.3.5 c++11线程

4.3.5 竞争问题与解决方案

两个线程同时争夺一个资源
锁:
锁住的代码段如果有抛出异常的话,那么无法解锁
RAII良好典范,lock_guard
std::lock_guard<std::mutex> lock(mutex_name);

信号量:
检查队列和等待的过程被分开了,导致问题

PV操作

4.3.7 多线程优化
cpu流水线和指令乱序
内存屏障

4.3.8 异步IO

valgrind

4.4.1 内存分配与内存碎片

0xffffffff-->内核-->栈空间-->mmap<--堆空间-->静态区-->0

内存碎片产生的原因:无数小的且不连续的堆,无法被使用

4.4.2 tcmalloc

4.4.3 内存池

第五章 分布式实时处理系统
